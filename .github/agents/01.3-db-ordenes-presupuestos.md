# Agent: Database - √ìrdenes, Presupuestos e Historial

> **Nota Importante:** Todos los procesos, informes y comunicaciones de este agente deben realizarse en espa√±ol hispanohablante para facilitar la comprensi√≥n y colaboraci√≥n del equipo.

## Rol
Especialista en Base de Datos enfocado en la implementaci√≥n de las tablas de √≥rdenes de reparaci√≥n, presupuestos, historial de estados y controles de entrega.

## Objetivo
Implementar las tablas `presupuestos`, `ordenes`, `historial_estados` y `controles_entrega` en el schema de Prisma, crear las relaciones correctas con clientes y equipos, implementar seeds con √≥rdenes en diferentes estados, y asegurar la trazabilidad completa del flujo de trabajo.

## Contexto del Proyecto
SalvaCell es un sistema de gesti√≥n integral para talleres de reparaci√≥n de dispositivos m√≥viles. Este agente se enfoca espec√≠ficamente en:
- Gesti√≥n de presupuestos que pueden convertirse en √≥rdenes
- √ìrdenes de reparaci√≥n con estados y seguimiento
- Historial completo de cambios de estado (auditor√≠a)
- Control de entrega del equipo (firma, verificaci√≥n)
- Generaci√≥n autom√°tica de folios √∫nicos
- Relaciones con clientes, equipos y usuarios

## Documentaci√≥n de Referencia
Revisar los siguientes documentos en la carpeta `/home/runner/work/SalvaCell/SalvaCell/docs/`:
- `FSD.md` - Secci√≥n 3.1 (modelos Presupuesto, Orden, HistorialEstadoOrden)
- `SRS.md` - Secci√≥n 3.3 (Presupuestos) y 3.4 (√ìrdenes)
- `PRD.md` - Secci√≥n 4 (Flujo de trabajo de √≥rdenes)
- `BRD.md` - Requisitos de negocio relacionados con √≥rdenes

## Prerequisitos
‚úÖ El agente `01-database-architect.md` debe haber creado el schema base
‚úÖ El agente `01.2-db-clientes-equipos.md` debe haber creado Cliente y Equipo
‚úÖ Debe existir el modelo `User` en el schema
‚úÖ PostgreSQL debe estar configurado

## Tareas Espec√≠ficas

### 1. Implementar Modelo Presupuesto
**Archivo:** `prisma/schema.prisma`

```prisma
model Presupuesto {
  id                String              @id @default(uuid())
  folio             String              @unique // PRE-YYYYMM###
  clienteId         String
  equipoId          String?
  tecnicoId         String
  
  // Informaci√≥n del equipo (si no existe en BD)
  equipoMarca       String?
  equipoModelo      String?
  equipoColor       String?
  equipoIMEI        String?
  
  // Detalles del presupuesto
  falla             String              @db.Text
  diagnostico       String?             @db.Text
  solucionPropuesta String?             @db.Text
  costoEstimado     Decimal             @db.Decimal(10, 2)
  tiempoEstimado    String?             // Ej: "2-3 d√≠as"
  
  // Estados y control
  estado            EstadoPresupuesto   @default(PENDIENTE)
  vigenciaHasta     DateTime
  fechaEnvio        DateTime?
  fechaRespuesta    DateTime?
  
  // Conversi√≥n a orden
  ordenId           String?             @unique
  fechaConversion   DateTime?
  
  // Notas
  notasInternas     String?             @db.Text
  
  // Timestamps
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relaciones
  cliente           Cliente             @relation(fields: [clienteId], references: [id], onDelete: Restrict)
  equipo            Equipo?             @relation(fields: [equipoId], references: [id], onDelete: Restrict)
  tecnico           User                @relation("PresupuestoTecnico", fields: [tecnicoId], references: [id], onDelete: Restrict)
  orden             Orden?              @relation("PresupuestoOrden")
  
  // √çndices
  @@index([folio])
  @@index([clienteId])
  @@index([estado])
  @@index([vigenciaHasta])
  @@index([createdAt])
  @@map("presupuestos")
}

enum EstadoPresupuesto {
  PENDIENTE   // Esperando respuesta del cliente
  ACEPTADO    // Cliente acept√≥, listo para conversi√≥n
  RECHAZADO   // Cliente rechaz√≥
  VENCIDO     // Pas√≥ la fecha de vigencia
  CONVERTIDO  // Ya se convirti√≥ en orden
}
```

**Validaciones importantes:**
- `folio` debe ser √∫nico con formato `PRE-YYYYMM###` (generado autom√°ticamente)
- `costoEstimado` con precisi√≥n decimal para montos
- `vigenciaHasta` para controlar presupuestos vencidos
- `ordenId` √∫nico para asegurar 1:1 con Orden
- `onDelete: Restrict` para prevenir eliminaci√≥n accidental

### 2. Implementar Modelo Orden
**Archivo:** `prisma/schema.prisma`

```prisma
model Orden {
  id                String              @id @default(uuid())
  folio             String              @unique // ORD-YYYYMM###
  clienteId         String
  equipoId          String
  tecnicoId         String
  presupuestoId     String?             @unique
  
  // Informaci√≥n de recepci√≥n
  falla             String              @db.Text
  accesorios        String?             @db.Text // "Cargador, funda, aud√≠fonos"
  patron            String?             // Patr√≥n de desbloqueo
  observaciones     String?             @db.Text
  
  // Diagn√≥stico y reparaci√≥n
  diagnostico       String?             @db.Text
  reparacionRealizada String?           @db.Text
  refaccionesUsadas String?             @db.Text // Descripci√≥n textual adicional
  
  // Costos
  costoRefacciones  Decimal             @default(0) @db.Decimal(10, 2)
  costoManoObra     Decimal             @default(0) @db.Decimal(10, 2)
  costoTotal        Decimal             @default(0) @db.Decimal(10, 2)
  
  // Pagos
  totalPagado       Decimal             @default(0) @db.Decimal(10, 2)
  adeudo            Decimal             @default(0) @db.Decimal(10, 2)
  
  // Estado y seguimiento
  estado            EstadoOrden         @default(RECIBIDO)
  prioridad         Prioridad           @default(NORMAL)
  fechaIngreso      DateTime            @default(now())
  fechaEstimada     DateTime?
  fechaTerminado    DateTime?
  fechaEntregado    DateTime?
  
  // Garant√≠a
  diasGarantia      Int                 @default(15)
  fechaVenceGarantia DateTime?
  
  // Control de entrega
  equipoEntregado   Boolean             @default(false)
  fechaEntrega      DateTime?
  entregadoA        String?
  firmaRecibido     String?             @db.Text // Base64 de la firma
  
  // Notas
  notasInternas     String?             @db.Text
  notasCliente      String?             @db.Text
  
  // Timestamps
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relaciones
  cliente           Cliente             @relation(fields: [clienteId], references: [id], onDelete: Restrict)
  equipo            Equipo              @relation(fields: [equipoId], references: [id], onDelete: Restrict)
  tecnico           User                @relation("OrdenTecnico", fields: [tecnicoId], references: [id], onDelete: Restrict)
  presupuesto       Presupuesto?        @relation("PresupuestoOrden", fields: [presupuestoId], references: [id])
  
  historialEstados  HistorialEstadoOrden[]
  refacciones       OrdenRefaccion[]
  pagos             Pago[]
  
  // √çndices
  @@index([folio])
  @@index([clienteId])
  @@index([equipoId])
  @@index([tecnicoId])
  @@index([estado])
  @@index([fechaIngreso])
  @@index([fechaEstimada])
  @@index([equipoEntregado])
  @@map("ordenes")
}

enum EstadoOrden {
  RECIBIDO        // Equipo recibido, esperando diagn√≥stico
  EN_DIAGNOSTICO  // T√©cnico revisando el equipo
  ESPERANDO_REFACCION // Falta refacci√≥n
  ESPERANDO_AUTORIZACION // Esperando que cliente autorice costo
  EN_REPARACION   // En proceso de reparaci√≥n
  REPARADO        // Reparaci√≥n completada, pendiente pruebas
  TERMINADO       // Listo para entrega
  ENTREGADO       // Entregado al cliente
  CANCELADO       // Orden cancelada
  EN_GARANTIA     // Regres√≥ por garant√≠a
}

enum Prioridad {
  BAJA
  NORMAL
  ALTA
  URGENTE
}
```

**Validaciones importantes:**
- `folio` √∫nico con formato `ORD-YYYYMM###`
- Todos los costos con precisi√≥n decimal `@db.Decimal(10, 2)`
- `adeudo` calculado autom√°ticamente: `costoTotal - totalPagado`
- `equipoEntregado` para prevenir entregas sin pago completo
- `onDelete: Restrict` para proteger datos hist√≥ricos

### 3. Implementar Modelo HistorialEstadoOrden
**Archivo:** `prisma/schema.prisma`

```prisma
model HistorialEstadoOrden {
  id            String      @id @default(uuid())
  ordenId       String
  estadoAnterior EstadoOrden?
  estadoNuevo   EstadoOrden
  usuarioId     String
  motivo        String?     @db.Text
  notas         String?     @db.Text
  createdAt     DateTime    @default(now())
  
  // Relaciones
  orden         Orden       @relation(fields: [ordenId], references: [id], onDelete: Cascade)
  usuario       User        @relation("HistorialEstadoUsuario", fields: [usuarioId], references: [id], onDelete: Restrict)
  
  // √çndices
  @@index([ordenId])
  @@index([createdAt])
  @@map("historial_estados_orden")
}
```

**Validaciones importantes:**
- Registra cada cambio de estado con usuario y timestamp
- `estadoAnterior` puede ser NULL para el primer estado
- `onDelete: Cascade` para que se elimine con la orden
- √çndice en `ordenId` para consultas r√°pidas de historial

### 4. Implementar Modelo ControlEntrega (Opcional pero recomendado)
**Archivo:** `prisma/schema.prisma`

```prisma
model ControlEntrega {
  id                String   @id @default(uuid())
  ordenId           String   @unique
  
  // Verificaci√≥n antes de entrega
  equipoFuncional   Boolean  @default(false)
  estadoExterior    String?  // "Excelente", "Bueno", "Regular"
  accesoriosDevueltos String? @db.Text
  
  // Informaci√≥n de entrega
  fechaEntrega      DateTime
  entregadoPor      String  // Usuario que entrega
  recibidoPor       String  // Nombre de quien recibe
  parentesco        String? // "Cliente", "Familiar", "Amigo"
  identificacion    String? // Tipo y n√∫mero de ID
  
  // Firma y confirmaci√≥n
  firmaRecibido     String?  @db.Text // Base64
  conformidad       Boolean  @default(false)
  
  // Notas
  observaciones     String?  @db.Text
  
  createdAt         DateTime @default(now())
  
  // Relaciones
  orden             Orden    @relation(fields: [ordenId], references: [id], onDelete: Cascade)
  
  @@map("controles_entrega")
}
```

### 5. Crear Seeds de Presupuestos
**Archivo:** `prisma/seed.ts`

Crear presupuestos con diferentes estados:

```typescript
// Ejemplo de seeds de presupuestos
const presupuestos = [
  // Presupuesto pendiente
  {
    folio: "PRE-202601001",
    clienteId: clienteVIP.id,
    equipoId: equipoiPhone13.id,
    tecnicoId: tecnicoUser.id,
    falla: "Pantalla rota, no enciende",
    diagnostico: "Necesita cambio de pantalla y revisi√≥n de placa base",
    solucionPropuesta: "Reemplazo de pantalla OLED original y verificaci√≥n de componentes internos",
    costoEstimado: 2500.00,
    tiempoEstimado: "2-3 d√≠as h√°biles",
    estado: "PENDIENTE",
    vigenciaHasta: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 d√≠as
  },
  
  // Presupuesto aceptado
  {
    folio: "PRE-202601002",
    clienteId: clienteFrecuente.id,
    equipoId: equipoSamsung.id,
    tecnicoId: tecnicoUser.id,
    falla: "Bater√≠a se descarga r√°pido",
    diagnostico: "Bater√≠a degradada, capacidad al 65%",
    solucionPropuesta: "Cambio de bater√≠a original Samsung",
    costoEstimado: 800.00,
    tiempoEstimado: "1 d√≠a",
    estado: "ACEPTADO",
    vigenciaHasta: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    fechaEnvio: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
    fechaRespuesta: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
  },
  
  // Presupuesto rechazado
  {
    folio: "PRE-202601003",
    clienteId: clienteNuevo.id,
    equipoMarca: "Xiaomi", // Sin equipo registrado en BD
    equipoModelo: "Redmi Note 9",
    equipoColor: "Gris",
    falla: "No carga",
    diagnostico: "Conector de carga da√±ado y posible problema en placa",
    solucionPropuesta: "Cambio de conector de carga y revisi√≥n de circuito de carga",
    costoEstimado: 1200.00,
    tiempoEstimado: "3-4 d√≠as",
    estado: "RECHAZADO",
    vigenciaHasta: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
    fechaEnvio: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
    fechaRespuesta: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
    notasInternas: "Cliente mencion√≥ que era muy caro, decidi√≥ no reparar",
  },
  
  // Presupuesto vencido
  {
    folio: "PRE-202601004",
    clienteId: clienteNuevo2.id,
    equipoMarca: "Motorola",
    equipoModelo: "Moto G9",
    falla: "Pantalla con l√≠neas",
    costoEstimado: 900.00,
    estado: "VENCIDO",
    vigenciaHasta: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000), // Vencido hace 10 d√≠as
    fechaEnvio: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000),
  },
];
```

**Total de presupuestos:** 8-10 con estados variados

### 6. Crear Seeds de √ìrdenes
**Archivo:** `prisma/seed.ts`

Crear √≥rdenes en diferentes estados para representar el flujo completo:

```typescript
const ordenes = [
  // Orden reci√©n recibida
  {
    folio: "ORD-202601001",
    clienteId: clienteVIP.id,
    equipoId: equipoiPhone13.id,
    tecnicoId: tecnicoUser.id,
    falla: "Pantalla rota, t√°ctil no responde",
    accesorios: "Cargador original, funda de silic√≥n roja",
    estado: "RECIBIDO",
    prioridad: "ALTA",
    fechaIngreso: new Date(),
    fechaEstimada: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000),
    costoTotal: 2500.00,
    costoManoObra: 500.00,
    costoRefacciones: 2000.00,
    adeudo: 2500.00,
    diasGarantia: 15,
  },
  
  // Orden en diagn√≥stico
  {
    folio: "ORD-202601002",
    clienteId: clienteFrecuente.id,
    equipoId: equipoSamsung.id,
    tecnicoId: tecnicoUser.id,
    falla: "No enciende, se moj√≥",
    accesorios: "Ninguno",
    estado: "EN_DIAGNOSTICO",
    prioridad: "NORMAL",
    fechaIngreso: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
    fechaEstimada: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000),
    costoTotal: 0, // A√∫n no se cotiza
    adeudo: 0,
    observaciones: "Cliente menciona que se cay√≥ en agua, limpiarlo con alcohol isoprop√≠lico",
  },
  
  // Orden esperando refacci√≥n
  {
    folio: "ORD-202601003",
    clienteId: clienteVIP.id,
    equipoId: equipoiPhone11.id,
    tecnicoId: tecnicoUser.id,
    presupuestoId: presupuestoAceptado.id, // Convertido desde presupuesto
    falla: "Bater√≠a inflada",
    accesorios: "Cargador, aud√≠fonos lightning",
    diagnostico: "Bater√≠a efectivamente inflada, riesgo de explosi√≥n. Reemplazo inmediato necesario.",
    estado: "ESPERANDO_REFACCION",
    prioridad: "ALTA",
    fechaIngreso: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
    costoTotal: 1800.00,
    costoManoObra: 300.00,
    costoRefacciones: 1500.00,
    totalPagado: 900.00, // Anticipo
    adeudo: 900.00,
    notasInternas: "Bater√≠a original agotada, pedido a proveedor #1234",
  },
  
  // Orden en reparaci√≥n
  {
    folio: "ORD-202601004",
    clienteId: clienteFrecuente.id,
    equipoId: equipoRedmi.id,
    tecnicoId: tecnicoUser.id,
    falla: "C√°mara frontal no funciona",
    diagnostico: "Flex de c√°mara da√±ado",
    reparacionRealizada: "Reemplazo de flex de c√°mara frontal",
    estado: "EN_REPARACION",
    prioridad: "NORMAL",
    fechaIngreso: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
    fechaEstimada: new Date(Date.now() + 1 * 24 * 60 * 60 * 1000),
    costoTotal: 600.00,
    costoManoObra: 200.00,
    costoRefacciones: 400.00,
    totalPagado: 600.00, // Pagado completo
    adeudo: 0,
  },
  
  // Orden terminada (lista para entrega)
  {
    folio: "ORD-202601005",
    clienteId: clienteNuevo.id,
    equipoId: equipoMoto.id,
    tecnicoId: tecnicoUser.id,
    falla: "No detecta SIM",
    diagnostico: "Lector de SIM sucio y pin doblado",
    reparacionRealizada: "Limpieza de lector SIM y correcci√≥n de pines",
    estado: "TERMINADO",
    prioridad: "NORMAL",
    fechaIngreso: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
    fechaTerminado: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
    costoTotal: 350.00,
    costoManoObra: 250.00,
    costoRefacciones: 100.00,
    totalPagado: 350.00,
    adeudo: 0,
    diasGarantia: 15,
    fechaVenceGarantia: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),
  },
  
  // Orden entregada
  {
    folio: "ORD-202601006",
    clienteId: clienteVIP.id,
    equipoId: equipoiPhoneXR.id,
    tecnicoId: tecnicoUser.id,
    falla: "Pantalla quebrada",
    diagnostico: "Solo da√±o de pantalla, componentes internos OK",
    reparacionRealizada: "Reemplazo de pantalla LCD gen√©rica de alta calidad",
    estado: "ENTREGADO",
    prioridad: "NORMAL",
    fechaIngreso: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000),
    fechaTerminado: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
    fechaEntregado: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000),
    costoTotal: 1400.00,
    costoManoObra: 300.00,
    costoRefacciones: 1100.00,
    totalPagado: 1400.00,
    adeudo: 0,
    equipoEntregado: true,
    entregadoA: "Roberto Gonz√°lez (Cliente)",
    diasGarantia: 15,
    fechaVenceGarantia: new Date(Date.now() + 11 * 24 * 60 * 60 * 1000),
  },
  
  // Orden cancelada
  {
    folio: "ORD-202601007",
    clienteId: clienteNuevo2.id,
    equipoId: equipoHuawei.id,
    tecnicoId: tecnicoUser.id,
    falla: "No enciende despu√©s de actualizaci√≥n",
    diagnostico: "Problema de software, posible brick. Requiere flasheo de ROM",
    estado: "CANCELADO",
    prioridad: "BAJA",
    fechaIngreso: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
    costoTotal: 0,
    adeudo: 0,
    notasInternas: "Cliente decidi√≥ no reparar, prefiere comprar equipo nuevo",
    notasCliente: "Gracias por el diagn√≥stico, pero prefiero cambiarlo",
  },
  
  // Orden con adeudo (alerta)
  {
    folio: "ORD-202601008",
    clienteId: clienteFrecuente2.id,
    equipoId: equipoXiaomi.id,
    tecnicoId: tecnicoUser.id,
    falla: "Conector de carga flojo",
    diagnostico: "Conector USB-C desgastado",
    reparacionRealizada: "Reemplazo de conector de carga",
    estado: "TERMINADO",
    prioridad: "NORMAL",
    fechaIngreso: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000),
    fechaTerminado: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
    costoTotal: 500.00,
    costoManoObra: 200.00,
    costoRefacciones: 300.00,
    totalPagado: 200.00, // Solo anticipo
    adeudo: 300.00, // Adeudo pendiente
    notasInternas: "ALERTA: Entregar solo cuando complete el pago",
  },
];
```

**Total de √≥rdenes:** 15-20 √≥rdenes con estados variados

### 7. Crear Seeds de Historial de Estados
**Archivo:** `prisma/seed.ts`

Para cada orden, crear 2-5 cambios de estado realistas:

```typescript
// Ejemplo para la orden ORD-202601004 (actualmente EN_REPARACION)
const historialOrden4 = [
  {
    ordenId: orden4.id,
    estadoAnterior: null,
    estadoNuevo: "RECIBIDO",
    usuarioId: recepcionistaUser.id,
    motivo: "Recepci√≥n inicial del equipo",
    notas: "Cliente entreg√≥ equipo con c√°mara frontal defectuosa",
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),
  },
  {
    ordenId: orden4.id,
    estadoAnterior: "RECIBIDO",
    estadoNuevo: "EN_DIAGNOSTICO",
    usuarioId: tecnicoUser.id,
    motivo: "Iniciando diagn√≥stico t√©cnico",
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000),
  },
  {
    ordenId: orden4.id,
    estadoAnterior: "EN_DIAGNOSTICO",
    estadoNuevo: "ESPERANDO_REFACCION",
    usuarioId: tecnicoUser.id,
    motivo: "Flex de c√°mara da√±ado, esperando refacci√≥n",
    notas: "Pedido realizado a proveedor XYZ",
    createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
  },
  {
    ordenId: orden4.id,
    estadoAnterior: "ESPERANDO_REFACCION",
    estadoNuevo: "EN_REPARACION",
    usuarioId: tecnicoUser.id,
    motivo: "Refacci√≥n recibida, iniciando reparaci√≥n",
    createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),
  },
];
```

### 8. Implementar Funciones Helper en Seed

```typescript
// Helper para generar folio de presupuesto
function generarFolioPresupuesto(numero: number): string {
  const fecha = new Date();
  const year = fecha.getFullYear();
  const month = String(fecha.getMonth() + 1).padStart(2, '0');
  const num = String(numero).padStart(3, '0');
  return `PRE-${year}${month}${num}`;
}

// Helper para generar folio de orden
function generarFolioOrden(numero: number): string {
  const fecha = new Date();
  const year = fecha.getFullYear();
  const month = String(fecha.getMonth() + 1).padStart(2, '0');
  const num = String(numero).padStart(3, '0');
  return `ORD-${year}${month}${num}`;
}

// Helper para calcular fecha de vencimiento de garant√≠a
function calcularVencimientoGarantia(fechaEntrega: Date, dias: number): Date {
  const vencimiento = new Date(fechaEntrega);
  vencimiento.setDate(vencimiento.getDate() + dias);
  return vencimiento;
}
```

## Criterios de √âxito

‚úÖ El modelo `Presupuesto` est√° completo con todos los campos y estados
‚úÖ El modelo `Orden` est√° completo con todos los campos y flujo de estados
‚úÖ El modelo `HistorialEstadoOrden` registra cada cambio de estado
‚úÖ Las relaciones est√°n correctamente definidas:
  - Presupuesto ‚Üí Orden (1:1 opcional)
  - Orden ‚Üí HistorialEstadoOrden (1:N)
  - Cliente ‚Üí Presupuestos (1:N)
  - Cliente ‚Üí Ordenes (1:N)

‚úÖ El seed crea al menos:
  - 8-10 presupuestos con estados variados
  - 15-20 √≥rdenes en diferentes estados del flujo
  - 50-80 registros de historial de estados
  - Folios √∫nicos y secuenciales

‚úÖ Los folios tienen el formato correcto (PRE-YYYYMM### y ORD-YYYYMM###)
‚úÖ Los costos est√°n en formato Decimal(10,2)
‚úÖ El campo `adeudo` refleja correctamente costoTotal - totalPagado
‚úÖ Las fechas son coherentes (fechaIngreso < fechaTerminado < fechaEntregado)

## Comandos de Verificaci√≥n

```bash
# Verificar el schema
npx prisma format
npx prisma validate

# Ver los datos en Prisma Studio
npx prisma studio

# Consultar √≥rdenes por estado
npx prisma db execute --stdin <<EOF
SELECT estado, COUNT(*) as total
FROM ordenes
GROUP BY estado
ORDER BY total DESC;
EOF

# Verificar folios √∫nicos
npx prisma db execute --stdin <<EOF
SELECT folio, COUNT(*) as duplicados
FROM ordenes
GROUP BY folio
HAVING COUNT(*) > 1;
EOF

# Ver historial de una orden espec√≠fica
npx prisma db execute --stdin <<EOF
SELECT h.*, u.name as usuario_nombre
FROM historial_estados_orden h
JOIN users u ON h."usuarioId" = u.id
WHERE h."ordenId" = 'ID_DE_LA_ORDEN'
ORDER BY h."createdAt" ASC;
EOF

# √ìrdenes con adeudo
npx prisma db execute --stdin <<EOF
SELECT o.folio, c.nombre, c.apellido, o."costoTotal", o."totalPagado", o.adeudo
FROM ordenes o
JOIN clientes c ON o."clienteId" = c.id
WHERE o.adeudo > 0
ORDER BY o.adeudo DESC;
EOF
```

## Notas Importantes

1. **Generaci√≥n de Folios:**
   - Usar formato `PRE-YYYYMM###` para presupuestos
   - Usar formato `ORD-YYYYMM###` para √≥rdenes
   - El backend debe obtener el √∫ltimo folio del mes y sumar 1

2. **Estados de Presupuesto:**
   - PENDIENTE ‚Üí ACEPTADO ‚Üí CONVERTIDO
   - PENDIENTE ‚Üí RECHAZADO
   - PENDIENTE ‚Üí VENCIDO (autom√°tico por fecha)

3. **Estados de Orden:**
   - Flujo normal: RECIBIDO ‚Üí EN_DIAGNOSTICO ‚Üí EN_REPARACION ‚Üí TERMINADO ‚Üí ENTREGADO
   - Flujos alternativos: ESPERANDO_REFACCION, ESPERANDO_AUTORIZACION, CANCELADO

4. **Auditor√≠a:**
   - SIEMPRE registrar cambio de estado en HistorialEstadoOrden
   - Incluir usuario que hizo el cambio
   - Opcional: motivo y notas

5. **C√°lculo de Adeudo:**
   - adeudo = costoTotal - totalPagado
   - Validar en backend antes de permitir entrega

6. **Garant√≠a:**
   - Calcular `fechaVenceGarantia` al entregar: fechaEntrega + diasGarantia
   - Por defecto 15 d√≠as

7. **Conversi√≥n Presupuesto ‚Üí Orden:**
   - Copiar datos del presupuesto a la orden
   - Actualizar estado del presupuesto a CONVERTIDO
   - Vincular presupuestoId en la orden

## Problemas Comunes y Soluciones

**Error: "Unique constraint failed on folio"**
- Soluci√≥n: Implementar l√≥gica de generaci√≥n secuencial en backend
- Usar transacci√≥n para obtener √∫ltimo folio + crear nuevo

**Fechas inconsistentes (fechaTerminado < fechaIngreso)**
- Soluci√≥n: Validar en backend con Zod que fechas sean l√≥gicas
- Agregar constraint check en PostgreSQL

**Adeudo negativo**
- Soluci√≥n: Validar que totalPagado <= costoTotal
- Recalcular adeudo en cada actualizaci√≥n

**Historial no se crea al cambiar estado**
- Soluci√≥n: Usar transacci√≥n en backend para actualizar orden + crear historial
- Considerar usar triggers de PostgreSQL

**No se puede entregar orden con adeudo**
- Soluci√≥n: Validar en backend antes de cambiar a ENTREGADO
- Solo permitir si adeudo = 0 O si admin lo autoriza

## Entregables

1. ‚úÖ Modelos `Presupuesto`, `Orden`, `HistorialEstadoOrden` en schema.prisma
2. ‚úÖ Enums `EstadoPresupuesto`, `EstadoOrden`, `Prioridad`
3. ‚úÖ √çndices optimizados para consultas frecuentes
4. ‚úÖ Seeds con 8-10 presupuestos variados
5. ‚úÖ Seeds con 15-20 √≥rdenes en diferentes estados
6. ‚úÖ Seeds con historial de estados para cada orden
7. ‚úÖ Migraci√≥n aplicada exitosamente
8. ‚úÖ Verificaci√≥n con Prisma Studio

## Siguiente Paso

Una vez completado este agente, el siguiente es:
üëâ **01.4-db-inventario-pagos.md** - Implementar tablas de inventario (refacciones, accesorios, movimientos) y pagos

## Referencias
- Documentaci√≥n Prisma Enums: https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#defining-enums
- Documentaci√≥n Prisma Decimal: https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#decimal
- Schema de referencia: `/docs/FSD.md` secci√≥n 3.1
- Requerimientos de √≥rdenes: `/docs/SRS.md` secci√≥n 3.3 y 3.4
