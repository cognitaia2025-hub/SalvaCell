# Agent: Clientes Backend

## Instrucción de Idioma
**IMPORTANTE:** Todos los procesos, informes, commits, y documentación generados por este agente deben realizarse en español hispanohablante para facilitar la comprensión del equipo.

## Rol
Ingeniero Backend especializado en desarrollo de APIs REST con Node.js, Express y Prisma ORM.

## Objetivo
Implementar el módulo completo de gestión de clientes en el backend, incluyendo CRUD, búsqueda inteligente, cálculo automático de badges (VIP/Frecuente/Nuevo), estadísticas del cliente, historial completo de reparaciones, detección de duplicados y funcionalidad de fusión.

## Contexto del Proyecto
SalvaCell requiere un sistema robusto de gestión de clientes que permita:
- Búsqueda rápida y eficiente por nombre, teléfono y email
- Clasificación automática de clientes según su historial
- Visualización completa del perfil con estadísticas y métricas de valor
- Detección inteligente de clientes duplicados
- Fusión de registros duplicados preservando toda la información

## Documentación de Referencia
Revisar los siguientes documentos en la carpeta `/home/runner/work/SalvaCell/SalvaCell/docs/`:
- `FSD.md` - Sección 3.1 (Modelo Cliente) y Sección 4.2 (API Endpoints de Clientes)
- `SRS.md` - Sección 3.2 (Gestión de Clientes) - RF-CLI-001 a RF-CLI-006
- `PRD.md` - Historias de usuario relacionadas con clientes
- `BRD.md` - Requisitos de negocio para gestión de clientes

## Pre-requisitos
✅ El agente `01-database-architect` debe haber completado:
  - Modelo Cliente en Prisma
  - Modelo Equipo relacionado
  - Modelo Orden relacionado
  - Índices en campos de búsqueda (telefono, nombre, apellido)

✅ El agente `02-backend-setup` debe haber completado:
  - Proyecto Express configurado
  - Middleware de validación
  - Estructura de carpetas (controllers, services, routes, validators)

✅ El agente `03-auth-security` debe haber completado:
  - Middleware de autenticación
  - Middleware de autorización (RBAC)

## Tareas Específicas

### 1. Crear Validadores con Zod

**Archivo:** `backend/src/validators/cliente.validator.ts`

```typescript
import { z } from 'zod';

// Validador para crear cliente
export const createClienteSchema = z.object({
  nombre: z.string()
    .min(2, { message: 'El nombre debe tener al menos 2 caracteres' })
    .max(100, { message: 'El nombre no puede exceder 100 caracteres' }),
  apellido: z.string()
    .min(2, { message: 'El apellido debe tener al menos 2 caracteres' })
    .max(100, { message: 'El apellido no puede exceder 100 caracteres' }),
  telefono: z.string()
    .min(10, { message: 'El teléfono debe tener al menos 10 dígitos' })
    .max(15, { message: 'El teléfono no puede exceder 15 dígitos' })
    .regex(/^[0-9+\-() ]+$/, { message: 'El teléfono solo puede contener números y símbolos +, -, (, )' }),
  telefonoAlterno: z.string()
    .min(10)
    .max(15)
    .regex(/^[0-9+\-() ]+$/)
    .optional()
    .nullable(),
  email: z.string()
    .email({ message: 'Email inválido' })
    .optional()
    .nullable(),
  direccion: z.string()
    .max(500, { message: 'La dirección no puede exceder 500 caracteres' })
    .optional()
    .nullable(),
  notas: z.string()
    .max(1000, { message: 'Las notas no pueden exceder 1000 caracteres' })
    .optional()
    .nullable(),
});

// Validador para actualizar cliente (todos los campos opcionales excepto los que se envíen)
export const updateClienteSchema = createClienteSchema.partial();

// Validador para búsqueda
export const searchClienteSchema = z.object({
  search: z.string().optional(),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
});

// Validador para fusión de clientes
export const fusionarClientesSchema = z.object({
  clienteIdPrincipal: z.string().uuid({ message: 'ID de cliente principal inválido' }),
  clienteIdDuplicado: z.string().uuid({ message: 'ID de cliente duplicado inválido' }),
});

export type CreateClienteInput = z.infer<typeof createClienteSchema>;
export type UpdateClienteInput = z.infer<typeof updateClienteSchema>;
export type SearchClienteInput = z.infer<typeof searchClienteSchema>;
export type FusionarClientesInput = z.infer<typeof fusionarClientesSchema>;
```

### 2. Crear Utilidades para Clientes

**Archivo:** `backend/src/utils/cliente.util.ts`

```typescript
/**
 * Normaliza un número de teléfono removiendo espacios, guiones y paréntesis
 */
export function normalizarTelefono(telefono: string): string {
  return telefono.replace(/[\s\-()]/g, '');
}

/**
 * Calcula el badge del cliente basado en su historial
 * @param totalOrdenes - Total de órdenes del cliente
 * @param ticketPromedio - Ticket promedio del cliente
 * @returns 'VIP' | 'FRECUENTE' | 'NUEVO'
 */
export function calcularBadgeCliente(
  totalOrdenes: number,
  ticketPromedio: number
): 'VIP' | 'FRECUENTE' | 'NUEVO' {
  // VIP: Más de 10 órdenes O ticket promedio mayor a $500
  if (totalOrdenes > 10 || ticketPromedio > 500) {
    return 'VIP';
  }
  
  // Frecuente: Entre 5 y 10 órdenes
  if (totalOrdenes >= 5 && totalOrdenes <= 10) {
    return 'FRECUENTE';
  }
  
  // Nuevo: Menos de 5 órdenes
  return 'NUEVO';
}

/**
 * Calcula la similitud entre dos strings usando Levenshtein Distance
 * @returns Porcentaje de similitud (0-100)
 */
export function calcularSimilitudTexto(str1: string, str2: string): number {
  const s1 = str1.toLowerCase().trim();
  const s2 = str2.toLowerCase().trim();
  
  if (s1 === s2) return 100;
  if (s1.length === 0 || s2.length === 0) return 0;
  
  const matriz: number[][] = [];
  
  // Inicializar matriz
  for (let i = 0; i <= s1.length; i++) {
    matriz[i] = [i];
  }
  for (let j = 0; j <= s2.length; j++) {
    matriz[0][j] = j;
  }
  
  // Calcular distancia de Levenshtein
  for (let i = 1; i <= s1.length; i++) {
    for (let j = 1; j <= s2.length; j++) {
      const costo = s1[i - 1] === s2[j - 1] ? 0 : 1;
      matriz[i][j] = Math.min(
        matriz[i - 1][j] + 1,      // eliminación
        matriz[i][j - 1] + 1,      // inserción
        matriz[i - 1][j - 1] + costo // sustitución
      );
    }
  }
  
  const distancia = matriz[s1.length][s2.length];
  const maxLength = Math.max(s1.length, s2.length);
  const similitud = ((maxLength - distancia) / maxLength) * 100;
  
  return Math.round(similitud);
}

/**
 * Compara dos números de teléfono normalizados
 */
export function telefonosSonIguales(tel1: string, tel2: string): boolean {
  const norm1 = normalizarTelefono(tel1);
  const norm2 = normalizarTelefono(tel2);
  return norm1 === norm2;
}
```

### 3. Crear Servicio de Clientes

**Archivo:** `backend/src/services/cliente.service.ts`

```typescript
import { BaseService } from './base.service';
import { 
  CreateClienteInput, 
  UpdateClienteInput,
  SearchClienteInput,
  FusionarClientesInput
} from '../validators/cliente.validator';
import { 
  normalizarTelefono, 
  calcularBadgeCliente,
  calcularSimilitudTexto,
  telefonosSonIguales
} from '../utils/cliente.util';

export class ClienteService extends BaseService {
  
  /**
   * Obtener lista de clientes con búsqueda y paginación
   */
  async getClientes(params: SearchClienteInput) {
    try {
      const { search, page, limit } = params;
      const skip = (page - 1) * limit;
      
      // Construir condiciones de búsqueda
      const whereConditions: any = {};
      
      if (search) {
        const searchNormalized = search.toLowerCase().trim();
        const telefonoNormalizado = normalizarTelefono(search);
        
        whereConditions.OR = [
          { nombre: { contains: searchNormalized, mode: 'insensitive' } },
          { apellido: { contains: searchNormalized, mode: 'insensitive' } },
          { telefono: { contains: telefonoNormalizado } },
          { email: { contains: searchNormalized, mode: 'insensitive' } },
        ];
      }
      
      // Obtener clientes
      const [clientes, total] = await Promise.all([
        this.prisma.cliente.findMany({
          where: whereConditions,
          include: {
            ordenes: {
              select: {
                id: true,
                folio: true,
                estado: true,
                costoTotal: true,
                adeudo: true,
              },
            },
            equipos: {
              select: {
                id: true,
                marca: true,
                modelo: true,
              },
            },
          },
          skip,
          take: limit,
          orderBy: [
            { updatedAt: 'desc' },
          ],
        }),
        this.prisma.cliente.count({ where: whereConditions }),
      ]);
      
      // Calcular estadísticas y badges para cada cliente
      const clientesConBadge = clientes.map((cliente) => {
        const totalOrdenes = cliente.ordenes.length;
        const ordenesEntregadas = cliente.ordenes.filter(o => o.estado === 'ENTREGADO');
        const totalGastado = ordenesEntregadas.reduce(
          (sum, orden) => sum + Number(orden.costoTotal), 
          0
        );
        const ticketPromedio = ordenesEntregadas.length > 0 
          ? totalGastado / ordenesEntregadas.length 
          : 0;
        const adeudoPendiente = cliente.ordenes.reduce(
          (sum, orden) => sum + Number(orden.adeudo),
          0
        );
        
        const badge = calcularBadgeCliente(totalOrdenes, ticketPromedio);
        
        return {
          ...cliente,
          estadisticas: {
            totalOrdenes,
            totalGastado,
            ticketPromedio,
            adeudoPendiente,
            badge,
          },
        };
      });
      
      return {
        clientes: clientesConBadge,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Obtener perfil completo de un cliente por ID
   */
  async getClienteById(id: string) {
    try {
      const cliente = await this.prisma.cliente.findUnique({
        where: { id },
        include: {
          ordenes: {
            include: {
              equipo: true,
              tecnico: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
            orderBy: {
              createdAt: 'desc',
            },
          },
          equipos: true,
          ventas: {
            include: {
              items: {
                include: {
                  accesorio: true,
                },
              },
            },
          },
        },
      });
      
      if (!cliente) {
        throw new Error('Cliente no encontrado');
      }
      
      // Calcular estadísticas completas
      const ordenesEntregadas = cliente.ordenes.filter(o => o.estado === 'ENTREGADO');
      const totalOrdenes = cliente.ordenes.length;
      const totalGastado = ordenesEntregadas.reduce(
        (sum, orden) => sum + Number(orden.costoTotal),
        0
      );
      const ticketPromedio = ordenesEntregadas.length > 0
        ? totalGastado / ordenesEntregadas.length
        : 0;
      const adeudoPendiente = cliente.ordenes.reduce(
        (sum, orden) => sum + Number(orden.adeudo),
        0
      );
      
      // Calcular CLV (Customer Lifetime Value)
      const totalVentas = cliente.ventas.reduce(
        (sum, venta) => sum + Number(venta.total),
        0
      );
      const clv = totalGastado + totalVentas;
      
      // Calcular frecuencia de visitas (órdenes por mes desde la primera orden)
      const primeraOrden = cliente.ordenes.length > 0
        ? cliente.ordenes[cliente.ordenes.length - 1].createdAt
        : new Date();
      const mesesDesdeInicio = Math.max(
        1,
        Math.ceil(
          (Date.now() - primeraOrden.getTime()) / (1000 * 60 * 60 * 24 * 30)
        )
      );
      const frecuenciaVisitas = totalOrdenes / mesesDesdeInicio;
      
      // Calcular badge
      const badge = calcularBadgeCliente(totalOrdenes, ticketPromedio);
      
      // Alertas
      const alertas = [];
      if (adeudoPendiente > 0) {
        alertas.push({
          tipo: 'ADEUDO',
          mensaje: `Cliente tiene adeudo pendiente de $${adeudoPendiente.toFixed(2)}`,
        });
      }
      
      const ordenesNoEntregadas = cliente.ordenes.filter(
        o => o.estado !== 'ENTREGADO' && o.estado !== 'CANCELADO'
      );
      if (ordenesNoEntregadas.length > 0) {
        alertas.push({
          tipo: 'ORDENES_PENDIENTES',
          mensaje: `Cliente tiene ${ordenesNoEntregadas.length} orden(es) pendiente(s)`,
          ordenes: ordenesNoEntregadas.map(o => ({
            folio: o.folio,
            estado: o.estado,
          })),
        });
      }
      
      // Garantías activas
      const garantiasActivas = cliente.ordenes.filter(
        o => o.tieneGarantia && 
        o.fechaVencimientoGarantia && 
        new Date(o.fechaVencimientoGarantia) > new Date()
      );
      if (garantiasActivas.length > 0) {
        alertas.push({
          tipo: 'GARANTIAS_ACTIVAS',
          mensaje: `Cliente tiene ${garantiasActivas.length} garantía(s) activa(s)`,
          garantias: garantiasActivas.map(o => ({
            folio: o.folio,
            vencimiento: o.fechaVencimientoGarantia,
          })),
        });
      }
      
      return {
        ...cliente,
        estadisticas: {
          totalOrdenes,
          totalGastado,
          ticketPromedio,
          adeudoPendiente,
          clv,
          frecuenciaVisitas: Number(frecuenciaVisitas.toFixed(2)),
          badge,
        },
        alertas,
      };
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Crear nuevo cliente
   */
  async createCliente(data: CreateClienteInput) {
    try {
      // Normalizar teléfono antes de guardar
      const telefonoNormalizado = normalizarTelefono(data.telefono);
      
      // Verificar si ya existe un cliente con ese teléfono
      const existente = await this.prisma.cliente.findUnique({
        where: { telefono: telefonoNormalizado },
      });
      
      if (existente) {
        throw new Error('Ya existe un cliente con ese número de teléfono');
      }
      
      // Crear cliente
      const cliente = await this.prisma.cliente.create({
        data: {
          ...data,
          telefono: telefonoNormalizado,
          telefonoAlterno: data.telefonoAlterno 
            ? normalizarTelefono(data.telefonoAlterno) 
            : null,
        },
      });
      
      return cliente;
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Actualizar cliente
   */
  async updateCliente(id: string, data: UpdateClienteInput) {
    try {
      // Verificar que el cliente existe
      const clienteExistente = await this.prisma.cliente.findUnique({
        where: { id },
      });
      
      if (!clienteExistente) {
        throw new Error('Cliente no encontrado');
      }
      
      // Si se está actualizando el teléfono, verificar que no esté en uso
      if (data.telefono) {
        const telefonoNormalizado = normalizarTelefono(data.telefono);
        const clienteConTelefono = await this.prisma.cliente.findFirst({
          where: {
            telefono: telefonoNormalizado,
            id: { not: id },
          },
        });
        
        if (clienteConTelefono) {
          throw new Error('Ya existe otro cliente con ese número de teléfono');
        }
        
        data.telefono = telefonoNormalizado;
      }
      
      // Normalizar teléfono alterno si se proporciona
      if (data.telefonoAlterno) {
        data.telefonoAlterno = normalizarTelefono(data.telefonoAlterno);
      }
      
      // Actualizar cliente
      const cliente = await this.prisma.cliente.update({
        where: { id },
        data,
      });
      
      return cliente;
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Eliminar cliente (solo si no tiene órdenes)
   */
  async deleteCliente(id: string) {
    try {
      // Verificar que el cliente existe
      const cliente = await this.prisma.cliente.findUnique({
        where: { id },
        include: {
          ordenes: true,
          ventas: true,
        },
      });
      
      if (!cliente) {
        throw new Error('Cliente no encontrado');
      }
      
      // Verificar que no tenga órdenes o ventas
      if (cliente.ordenes.length > 0 || cliente.ventas.length > 0) {
        throw new Error(
          'No se puede eliminar un cliente con órdenes o ventas registradas'
        );
      }
      
      // Eliminar cliente
      await this.prisma.cliente.delete({
        where: { id },
      });
      
      return { message: 'Cliente eliminado exitosamente' };
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Detectar clientes duplicados
   */
  async detectarDuplicados() {
    try {
      const clientes = await this.prisma.cliente.findMany({
        select: {
          id: true,
          nombre: true,
          apellido: true,
          telefono: true,
        },
      });
      
      const duplicados = [];
      
      // Comparar cada cliente con los demás
      for (let i = 0; i < clientes.length; i++) {
        for (let j = i + 1; j < clientes.length; j++) {
          const cliente1 = clientes[i];
          const cliente2 = clientes[j];
          
          const nombreCompleto1 = `${cliente1.nombre} ${cliente1.apellido}`;
          const nombreCompleto2 = `${cliente2.nombre} ${cliente2.apellido}`;
          
          const similitudNombre = calcularSimilitudTexto(
            nombreCompleto1,
            nombreCompleto2
          );
          
          const telefonosIguales = telefonosSonIguales(
            cliente1.telefono,
            cliente2.telefono
          );
          
          // Considerar duplicado si:
          // - Los nombres son muy similares (>80%) O
          // - Los teléfonos son iguales
          if (similitudNombre > 80 || telefonosIguales) {
            duplicados.push({
              cliente1: {
                id: cliente1.id,
                nombre: nombreCompleto1,
                telefono: cliente1.telefono,
              },
              cliente2: {
                id: cliente2.id,
                nombre: nombreCompleto2,
                telefono: cliente2.telefono,
              },
              similitudNombre,
              telefonosIguales,
            });
          }
        }
      }
      
      return duplicados;
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Fusionar dos clientes duplicados
   */
  async fusionarClientes(data: FusionarClientesInput) {
    try {
      const { clienteIdPrincipal, clienteIdDuplicado } = data;
      
      // Verificar que ambos clientes existen
      const [clientePrincipal, clienteDuplicado] = await Promise.all([
        this.prisma.cliente.findUnique({
          where: { id: clienteIdPrincipal },
          include: {
            ordenes: true,
            equipos: true,
            ventas: true,
          },
        }),
        this.prisma.cliente.findUnique({
          where: { id: clienteIdDuplicado },
          include: {
            ordenes: true,
            equipos: true,
            ventas: true,
          },
        }),
      ]);
      
      if (!clientePrincipal) {
        throw new Error('Cliente principal no encontrado');
      }
      
      if (!clienteDuplicado) {
        throw new Error('Cliente duplicado no encontrado');
      }
      
      // Realizar la fusión en una transacción
      await this.prisma.$transaction(async (tx) => {
        // 1. Transferir todas las órdenes al cliente principal
        await tx.orden.updateMany({
          where: { clienteId: clienteIdDuplicado },
          data: { clienteId: clienteIdPrincipal },
        });
        
        // 2. Transferir equipos sin duplicar IMEI
        const equiposPrincipal = clientePrincipal.equipos
          .filter(e => e.imei)
          .map(e => e.imei);
        
        for (const equipo of clienteDuplicado.equipos) {
          if (!equipo.imei || !equiposPrincipal.includes(equipo.imei)) {
            await tx.equipo.update({
              where: { id: equipo.id },
              data: { clienteId: clienteIdPrincipal },
            });
          } else {
            // Si ya existe el IMEI, eliminar el equipo duplicado
            await tx.equipo.delete({
              where: { id: equipo.id },
            });
          }
        }
        
        // 3. Transferir ventas
        await tx.venta.updateMany({
          where: { clienteId: clienteIdDuplicado },
          data: { clienteId: clienteIdPrincipal },
        });
        
        // 4. Actualizar datos del cliente principal si el duplicado tiene info adicional
        const updateData: any = {};
        if (!clientePrincipal.email && clienteDuplicado.email) {
          updateData.email = clienteDuplicado.email;
        }
        if (!clientePrincipal.direccion && clienteDuplicado.direccion) {
          updateData.direccion = clienteDuplicado.direccion;
        }
        if (!clientePrincipal.telefonoAlterno && clienteDuplicado.telefonoAlterno) {
          updateData.telefonoAlterno = clienteDuplicado.telefonoAlterno;
        }
        // Combinar notas
        if (clienteDuplicado.notas) {
          updateData.notas = clientePrincipal.notas
            ? `${clientePrincipal.notas}\n\n--- Fusionado ---\n${clienteDuplicado.notas}`
            : clienteDuplicado.notas;
        }
        
        if (Object.keys(updateData).length > 0) {
          await tx.cliente.update({
            where: { id: clienteIdPrincipal },
            data: updateData,
          });
        }
        
        // 5. Eliminar el cliente duplicado
        await tx.cliente.delete({
          where: { id: clienteIdDuplicado },
        });
      });
      
      // Obtener el cliente fusionado con toda su información
      const clienteFusionado = await this.getClienteById(clienteIdPrincipal);
      
      return {
        message: 'Clientes fusionados exitosamente',
        cliente: clienteFusionado,
      };
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Obtener historial completo de órdenes del cliente
   */
  async getHistorialOrdenes(clienteId: string) {
    try {
      const ordenes = await this.prisma.orden.findMany({
        where: { clienteId },
        include: {
          equipo: true,
          tecnico: {
            select: {
              id: true,
              name: true,
            },
          },
          historialEstados: {
            orderBy: {
              createdAt: 'desc',
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });
      
      return ordenes;
    } catch (error) {
      this.handleError(error);
    }
  }
  
  /**
   * Obtener equipos del cliente
   */
  async getEquiposCliente(clienteId: string) {
    try {
      const equipos = await this.prisma.equipo.findMany({
        where: { clienteId },
        include: {
          ordenes: {
            select: {
              id: true,
              folio: true,
              estado: true,
            },
          },
        },
      });
      
      return equipos;
    } catch (error) {
      this.handleError(error);
    }
  }
}
```

### 4. Crear Controlador de Clientes

**Archivo:** `backend/src/controllers/cliente.controller.ts`

```typescript
import { Request, Response } from 'express';
import { BaseController } from './base.controller';
import { ClienteService } from '../services/cliente.service';
import {
  createClienteSchema,
  updateClienteSchema,
  searchClienteSchema,
  fusionarClientesSchema,
} from '../validators/cliente.validator';

export class ClienteController extends BaseController {
  private clienteService = new ClienteService();
  
  /**
   * GET /api/clientes
   * Listar clientes con búsqueda y paginación
   */
  getClientes = this.asyncHandler(async (req: Request, res: Response) => {
    const params = searchClienteSchema.parse({
      search: req.query.search,
      page: req.query.page,
      limit: req.query.limit,
    });
    
    const result = await this.clienteService.getClientes(params);
    
    return this.sendSuccess(res, result, 'Clientes obtenidos exitosamente');
  });
  
  /**
   * GET /api/clientes/:id
   * Obtener perfil completo de un cliente
   */
  getClienteById = this.asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;
    
    const result = await this.clienteService.getClienteById(id);
    
    return this.sendSuccess(res, result, 'Cliente obtenido exitosamente');
  });
  
  /**
   * POST /api/clientes
   * Crear nuevo cliente
   */
  createCliente = this.asyncHandler(async (req: Request, res: Response) => {
    const validatedData = createClienteSchema.parse(req.body);
    
    const result = await this.clienteService.createCliente(validatedData);
    
    return this.sendSuccess(res, result, 'Cliente creado exitosamente', 201);
  });
  
  /**
   * PUT /api/clientes/:id
   * Actualizar cliente
   */
  updateCliente = this.asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;
    const validatedData = updateClienteSchema.parse(req.body);
    
    const result = await this.clienteService.updateCliente(id, validatedData);
    
    return this.sendSuccess(res, result, 'Cliente actualizado exitosamente');
  });
  
  /**
   * DELETE /api/clientes/:id
   * Eliminar cliente (solo si no tiene órdenes)
   */
  deleteCliente = this.asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;
    
    const result = await this.clienteService.deleteCliente(id);
    
    return this.sendSuccess(res, result, 'Cliente eliminado exitosamente');
  });
  
  /**
   * GET /api/clientes/duplicados/detectar
   * Detectar clientes duplicados
   */
  detectarDuplicados = this.asyncHandler(async (req: Request, res: Response) => {
    const result = await this.clienteService.detectarDuplicados();
    
    return this.sendSuccess(
      res,
      result,
      `Se encontraron ${result.length} posible(s) duplicado(s)`
    );
  });
  
  /**
   * POST /api/clientes/fusionar
   * Fusionar dos clientes duplicados
   */
  fusionarClientes = this.asyncHandler(async (req: Request, res: Response) => {
    const validatedData = fusionarClientesSchema.parse(req.body);
    
    const result = await this.clienteService.fusionarClientes(validatedData);
    
    return this.sendSuccess(res, result, 'Clientes fusionados exitosamente');
  });
  
  /**
   * GET /api/clientes/:id/historial
   * Obtener historial de órdenes del cliente
   */
  getHistorialOrdenes = this.asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;
    
    const result = await this.clienteService.getHistorialOrdenes(id);
    
    return this.sendSuccess(res, result, 'Historial obtenido exitosamente');
  });
  
  /**
   * GET /api/clientes/:id/equipos
   * Obtener equipos del cliente
   */
  getEquiposCliente = this.asyncHandler(async (req: Request, res: Response) => {
    const { id } = req.params;
    
    const result = await this.clienteService.getEquiposCliente(id);
    
    return this.sendSuccess(res, result, 'Equipos obtenidos exitosamente');
  });
}
```

### 5. Crear Rutas de Clientes

**Archivo:** `backend/src/routes/cliente.routes.ts`

```typescript
import { Router } from 'express';
import { ClienteController } from '../controllers/cliente.controller';
import { authenticate } from '../middleware/auth.middleware';
import { authorize } from '../middleware/rbac.middleware';

const router = Router();
const clienteController = new ClienteController();

// Todas las rutas requieren autenticación
router.use(authenticate);

// GET /api/clientes - Listar clientes (todos los roles)
router.get('/', clienteController.getClientes);

// GET /api/clientes/duplicados/detectar - Detectar duplicados (solo ADMIN)
router.get(
  '/duplicados/detectar',
  authorize('ADMIN'),
  clienteController.detectarDuplicados
);

// POST /api/clientes/fusionar - Fusionar clientes (solo ADMIN)
router.post(
  '/fusionar',
  authorize('ADMIN'),
  clienteController.fusionarClientes
);

// GET /api/clientes/:id - Obtener cliente por ID (todos los roles)
router.get('/:id', clienteController.getClienteById);

// POST /api/clientes - Crear cliente (ADMIN y RECEPCIONISTA)
router.post(
  '/',
  authorize('ADMIN', 'RECEPCIONISTA'),
  clienteController.createCliente
);

// PUT /api/clientes/:id - Actualizar cliente (ADMIN y RECEPCIONISTA)
router.put(
  '/:id',
  authorize('ADMIN', 'RECEPCIONISTA'),
  clienteController.updateCliente
);

// DELETE /api/clientes/:id - Eliminar cliente (solo ADMIN)
router.delete(
  '/:id',
  authorize('ADMIN'),
  clienteController.deleteCliente
);

// GET /api/clientes/:id/historial - Historial de órdenes (todos los roles)
router.get('/:id/historial', clienteController.getHistorialOrdenes);

// GET /api/clientes/:id/equipos - Equipos del cliente (todos los roles)
router.get('/:id/equipos', clienteController.getEquiposCliente);

export default router;
```

### 6. Integrar Rutas en el Index Principal

**Actualizar:** `backend/src/index.ts`

Agregar la importación y uso de las rutas de clientes:

```typescript
// ... imports existentes
import clienteRoutes from './routes/cliente.routes';

// ... configuración existente

// Rutas
app.use('/api/auth', authRoutes);
app.use('/api/clientes', clienteRoutes); // ← Agregar esta línea

// ... resto del código
```

### 7. Crear Tests de Clientes

**Archivo:** `backend/tests/cliente.test.ts`

```typescript
import request from 'supertest';
import app from '../src/index';

describe('Cliente Endpoints', () => {
  let token: string;
  let clienteId: string;
  
  beforeAll(async () => {
    // Login para obtener token
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'admin@salvacell.com',
        password: 'Admin123!',
      });
    
    token = loginResponse.body.data.token;
  });
  
  describe('POST /api/clientes', () => {
    it('should create a new cliente', async () => {
      const response = await request(app)
        .post('/api/clientes')
        .set('Authorization', `Bearer ${token}`)
        .send({
          nombre: 'Juan',
          apellido: 'Pérez',
          telefono: '5551234567',
          email: 'juan@example.com',
        });
      
      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id');
      
      clienteId = response.body.data.id;
    });
    
    it('should reject duplicate telefono', async () => {
      const response = await request(app)
        .post('/api/clientes')
        .set('Authorization', `Bearer ${token}`)
        .send({
          nombre: 'Pedro',
          apellido: 'García',
          telefono: '5551234567', // Mismo teléfono
        });
      
      expect(response.status).toBe(500);
      expect(response.body.success).toBe(false);
    });
  });
  
  describe('GET /api/clientes', () => {
    it('should list clientes with search', async () => {
      const response = await request(app)
        .get('/api/clientes?search=Juan')
        .set('Authorization', `Bearer ${token}`);
      
      expect(response.status).toBe(200);
      expect(response.body.data).toHaveProperty('clientes');
      expect(response.body.data).toHaveProperty('pagination');
    });
  });
  
  describe('GET /api/clientes/:id', () => {
    it('should get cliente profile with stats', async () => {
      const response = await request(app)
        .get(`/api/clientes/${clienteId}`)
        .set('Authorization', `Bearer ${token}`);
      
      expect(response.status).toBe(200);
      expect(response.body.data).toHaveProperty('estadisticas');
      expect(response.body.data.estadisticas).toHaveProperty('badge');
    });
  });
  
  describe('PUT /api/clientes/:id', () => {
    it('should update cliente', async () => {
      const response = await request(app)
        .put(`/api/clientes/${clienteId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({
          direccion: 'Calle Nueva 123',
        });
      
      expect(response.status).toBe(200);
      expect(response.body.data.direccion).toBe('Calle Nueva 123');
    });
  });
  
  describe('GET /api/clientes/duplicados/detectar', () => {
    it('should detect duplicate clientes', async () => {
      const response = await request(app)
        .get('/api/clientes/duplicados/detectar')
        .set('Authorization', `Bearer ${token}`);
      
      expect(response.status).toBe(200);
      expect(Array.isArray(response.body.data)).toBe(true);
    });
  });
});
```

## Criterios de Éxito

✅ **CRUD de Clientes completo:**
  - GET /api/clientes (con búsqueda y paginación) ✅
  - GET /api/clientes/:id (perfil completo con estadísticas) ✅
  - POST /api/clientes ✅
  - PUT /api/clientes/:id ✅
  - DELETE /api/clientes/:id (solo si no tiene órdenes) ✅

✅ **Búsqueda Inteligente:**
  - Búsqueda por nombre (case-insensitive) ✅
  - Búsqueda por apellido ✅
  - Búsqueda por teléfono (normalizado) ✅
  - Búsqueda por email ✅

✅ **Cálculo Automático de Badges:**
  - VIP: >10 órdenes O ticket promedio >$500 ✅
  - FRECUENTE: 5-10 órdenes ✅
  - NUEVO: <5 órdenes ✅

✅ **Estadísticas del Cliente:**
  - Total de órdenes ✅
  - Total gastado ✅
  - Ticket promedio ✅
  - Adeudo pendiente ✅
  - CLV (Customer Lifetime Value) ✅
  - Frecuencia de visitas ✅

✅ **Alertas Automáticas:**
  - Adeudos pendientes ✅
  - Órdenes no entregadas ✅
  - Garantías activas ✅

✅ **Detección de Duplicados:**
  - Similitud de nombre usando Levenshtein Distance ✅
  - Detección de teléfonos iguales con formato diferente ✅

✅ **Fusión de Clientes:**
  - Transferir órdenes ✅
  - Consolidar equipos sin duplicar IMEI ✅
  - Transferir ventas ✅
  - Combinar información de contacto ✅
  - Registrar en transacción (atomicidad) ✅

✅ **Historial y Timeline:**
  - GET /api/clientes/:id/historial ✅
  - GET /api/clientes/:id/equipos ✅

✅ **Permisos RBAC:**
  - ADMIN: Acceso completo ✅
  - TECNICO: Solo lectura ✅
  - RECEPCIONISTA: CRUD completo ✅

## Comandos de Verificación

```bash
# Iniciar servidor
npm run dev

# Crear un cliente
curl -X POST http://localhost:5000/api/clientes \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "nombre": "Juan",
    "apellido": "Pérez",
    "telefono": "5551234567",
    "email": "juan@example.com"
  }'

# Buscar clientes
curl -X GET "http://localhost:5000/api/clientes?search=Juan&page=1&limit=10" \
  -H "Authorization: Bearer $TOKEN"

# Obtener perfil completo
curl -X GET http://localhost:5000/api/clientes/{id} \
  -H "Authorization: Bearer $TOKEN"

# Detectar duplicados
curl -X GET http://localhost:5000/api/clientes/duplicados/detectar \
  -H "Authorization: Bearer $TOKEN"

# Fusionar clientes
curl -X POST http://localhost:5000/api/clientes/fusionar \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "clienteIdPrincipal": "uuid1",
    "clienteIdDuplicado": "uuid2"
  }'

# Ejecutar tests
npm test -- cliente.test.ts
```

## Ejemplo de Respuesta

### GET /api/clientes/:id

```json
{
  "success": true,
  "message": "Cliente obtenido exitosamente",
  "data": {
    "id": "uuid",
    "nombre": "Juan",
    "apellido": "Pérez",
    "telefono": "5551234567",
    "email": "juan@example.com",
    "ordenes": [...],
    "equipos": [...],
    "ventas": [...],
    "estadisticas": {
      "totalOrdenes": 12,
      "totalGastado": 6500.00,
      "ticketPromedio": 541.67,
      "adeudoPendiente": 0,
      "clv": 7200.00,
      "frecuenciaVisitas": 2.4,
      "badge": "VIP"
    },
    "alertas": [
      {
        "tipo": "GARANTIAS_ACTIVAS",
        "mensaje": "Cliente tiene 1 garantía(s) activa(s)",
        "garantias": [...]
      }
    ]
  }
}
```

## Problemas Comunes y Soluciones

**Error: "Ya existe un cliente con ese número de teléfono"**
- Solución: El teléfono debe ser único. Verificar si el cliente ya existe o usar el existente.

**Búsqueda no encuentra clientes**
- Solución: Verificar que los índices estén creados en Prisma. Ejecutar `npx prisma migrate dev`.

**Badge incorrecto**
- Solución: Verificar la lógica en `calcularBadgeCliente()`. Ajustar umbrales si es necesario.

**Fusión falla**
- Solución: Verificar que ambos IDs existan. La fusión debe ejecutarse en una transacción.

## Entregables

1. ✅ `backend/src/validators/cliente.validator.ts` - Validaciones Zod
2. ✅ `backend/src/utils/cliente.util.ts` - Utilidades (normalización, badges, duplicados)
3. ✅ `backend/src/services/cliente.service.ts` - Lógica de negocio
4. ✅ `backend/src/controllers/cliente.controller.ts` - Controlador
5. ✅ `backend/src/routes/cliente.routes.ts` - Rutas
6. ✅ `backend/tests/cliente.test.ts` - Tests
7. ✅ Rutas integradas en `src/index.ts`

## Próximos Pasos

Una vez completado este módulo, los siguientes agentes podrán:
- **04.2-clientes-frontend**: Implementar UI para gestión de clientes
- **06.1-ordenes-backend**: Vincular órdenes con clientes y usar estadísticas
- **05.1-presupuestos-backend**: Vincular presupuestos con clientes

## Referencias

- Prisma Docs: https://www.prisma.io/docs
- Zod Validation: https://zod.dev/
- Express.js: https://expressjs.com/
- Levenshtein Distance: https://en.wikipedia.org/wiki/Levenshtein_distance
